[
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "detectWithThreshold",
        "importPath": "Detect",
        "description": "Detect",
        "isExtraImport": true,
        "detail": "Detect",
        "documentation": {}
    },
    {
        "label": "detectWithThreshold",
        "importPath": "Detect",
        "description": "Detect",
        "isExtraImport": true,
        "detail": "Detect",
        "documentation": {}
    },
    {
        "label": "segmentChannelByBuffer",
        "importPath": "Buffer",
        "description": "Buffer",
        "isExtraImport": true,
        "detail": "Buffer",
        "documentation": {}
    },
    {
        "label": "segmentChannelByBuffer",
        "importPath": "Buffer",
        "description": "Buffer",
        "isExtraImport": true,
        "detail": "Buffer",
        "documentation": {}
    },
    {
        "label": "separateChannelData",
        "importPath": "Buffer",
        "description": "Buffer",
        "isExtraImport": true,
        "detail": "Buffer",
        "documentation": {}
    },
    {
        "label": "getDataFromFile",
        "importPath": "Utils",
        "description": "Utils",
        "isExtraImport": true,
        "detail": "Utils",
        "documentation": {}
    },
    {
        "label": "getDataFromFile",
        "importPath": "Utils",
        "description": "Utils",
        "isExtraImport": true,
        "detail": "Utils",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "calibrate",
        "importPath": "Calibration",
        "description": "Calibration",
        "isExtraImport": true,
        "detail": "Calibration",
        "documentation": {}
    },
    {
        "label": "calibrate",
        "importPath": "Calibration",
        "description": "Calibration",
        "isExtraImport": true,
        "detail": "Calibration",
        "documentation": {}
    },
    {
        "label": "printTwoBlinks",
        "importPath": "PrintData",
        "description": "PrintData",
        "isExtraImport": true,
        "detail": "PrintData",
        "documentation": {}
    },
    {
        "label": "pyxdf",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyxdf",
        "description": "pyxdf",
        "detail": "pyxdf",
        "documentation": {}
    },
    {
        "label": "bufferSizesFromChannel",
        "kind": 2,
        "importPath": "Buffer",
        "description": "Buffer",
        "peekOfCode": "def bufferSizesFromChannel(channel_data :list[float], bufferSize :int = 150):\n    channel_size : int = len(channel_data)\n    buffer_start_points :list[int] = [0]\n    check :int = bufferSize\n    while check <= channel_size:\n        buffer_start_points.append(check)\n        check += bufferSize\n    return buffer_start_points\ndef bufferChannel(channel_data :list[float], buffer_sizes_for_channel :list[int]):\n    buffer_list_size = len(buffer_sizes_for_channel)",
        "detail": "Buffer",
        "documentation": {}
    },
    {
        "label": "bufferChannel",
        "kind": 2,
        "importPath": "Buffer",
        "description": "Buffer",
        "peekOfCode": "def bufferChannel(channel_data :list[float], buffer_sizes_for_channel :list[int]):\n    buffer_list_size = len(buffer_sizes_for_channel)\n    buffered_channel :list[float] = []\n    for i in  range(buffer_list_size - 1): #-1 to prevent overflow with i+1\n        start = buffer_sizes_for_channel[i]\n        stop = buffer_sizes_for_channel[i+1]\n        buffered_channel.append(channel_data[start:stop])\n    return buffered_channel\ndef separateChannelData(raw_data :list[list[float]]):\n    num_channels :int = raw_data.shape[1] // 2",
        "detail": "Buffer",
        "documentation": {}
    },
    {
        "label": "separateChannelData",
        "kind": 2,
        "importPath": "Buffer",
        "description": "Buffer",
        "peekOfCode": "def separateChannelData(raw_data :list[list[float]]):\n    num_channels :int = raw_data.shape[1] // 2\n    channels :list[list[float]] = []\n    for i in range(num_channels):\n        x = raw_data[:, 2 * i] \n        y = raw_data[:, 2 * i + 1]\n        channel_data = np.stack((x, y), axis=1) \n        channels.append(channel_data)\n    return channels\ndef segmentChannelByBuffer(channel_data :list[float], buffer_size = 10):",
        "detail": "Buffer",
        "documentation": {}
    },
    {
        "label": "segmentChannelByBuffer",
        "kind": 2,
        "importPath": "Buffer",
        "description": "Buffer",
        "peekOfCode": "def segmentChannelByBuffer(channel_data :list[float], buffer_size = 10):\n    buffer_sizes_for_channel :list[int] = bufferSizesFromChannel(channel_data, buffer_size)\n    segmentedChannelByBuffer :list[list[float]] = bufferChannel(channel_data,buffer_sizes_for_channel)\n    return segmentedChannelByBuffer",
        "detail": "Buffer",
        "documentation": {}
    },
    {
        "label": "findAverageBlinkHeight",
        "kind": 2,
        "importPath": "Calibration",
        "description": "Calibration",
        "peekOfCode": "def findAverageBlinkHeight(is_there_blink_in_buffer :list[bool], segmented_channel_by_buffer :list[list[float]]):\n    total = num = 0\n    for blink, channel in zip(is_there_blink_in_buffer, segmented_channel_by_buffer):\n        if blink:\n            total += np.max(channel)\n            num += 1\n    try:\n        return total / num \n    except ZeroDivisionError:\n        return 0",
        "detail": "Calibration",
        "documentation": {}
    },
    {
        "label": "calibrate",
        "kind": 2,
        "importPath": "Calibration",
        "description": "Calibration",
        "peekOfCode": "def calibrate(path=r'data\\calibration\\calibration_data_nathan.xdf'):\n    calibration_channels :list[float] = getDataFromFile(path) # TODO : make a better calibration data set, later will be done before blink detection\n    calibration_channel1 = calibration_channels[0]\n    calibration_channel2 = calibration_channels[1]\n    # find baseline\n        # when measuring calibration, make sure a lot of the sample does not contain the signal, mostly noise\n        # we might just let 15 seconds pass and allow the subject to blink normally to calibrate on this data\n    baseline1 :float = np.mean(calibration_channel1) \n    baseline2 :float = np.mean(calibration_channel2) \n    # put both channels baseline at 0",
        "detail": "Calibration",
        "documentation": {}
    },
    {
        "label": "cleanDetect",
        "kind": 2,
        "importPath": "Detect",
        "description": "Detect",
        "peekOfCode": "def cleanDetect(is_there_blink_in_buffer :list[bool]):\n    previous :bool = False\n    size :int = len(is_there_blink_in_buffer)\n    for i in range(size):\n        temp :bool = previous\n        previous :bool = is_there_blink_in_buffer[i]\n        if is_there_blink_in_buffer[i] and temp:\n            is_there_blink_in_buffer[i] = False\n    return is_there_blink_in_buffer\ndef detectWithThreshold(segmented_channel_by_buffer :list[list[float]], threshold :int = 150):",
        "detail": "Detect",
        "documentation": {}
    },
    {
        "label": "detectWithThreshold",
        "kind": 2,
        "importPath": "Detect",
        "description": "Detect",
        "peekOfCode": "def detectWithThreshold(segmented_channel_by_buffer :list[list[float]], threshold :int = 150):\n    ret :list[bool] = []\n    for buffer in segmented_channel_by_buffer:   \n        ret.append(any(buffer[:] >= threshold))    \n    return cleanDetect(ret)",
        "detail": "Detect",
        "documentation": {}
    },
    {
        "label": "deserializeJSONToObject",
        "kind": 2,
        "importPath": "Eval",
        "description": "Eval",
        "peekOfCode": "def deserializeJSONToObject(path):  \n    import json\n    file = open(path)\n    return json.loads(file)",
        "detail": "Eval",
        "documentation": {}
    },
    {
        "label": "detectBlinksFromChannels",
        "kind": 2,
        "importPath": "Main",
        "description": "Main",
        "peekOfCode": "def detectBlinksFromChannels(channels :list[list[float]], thresholds :list[float]):\n    [channel_data1, channel_data2] = channels\n    [threshold1, threshold2] = thresholds\n    buffer_size = 5\n    segmented_channel_by_buffer1 :list[list[float]] = segmentChannelByBuffer(channel_data1, buffer_size)\n    segmented_channel_by_buffer2 :list[list[float]] = segmentChannelByBuffer(channel_data2, buffer_size)\n    is_there_blink_in_buffer1 :list[bool] = detectWithThreshold(segmented_channel_by_buffer1, threshold1)\n    is_there_blink_in_buffer2 :list[bool] = detectWithThreshold(segmented_channel_by_buffer2, threshold2)\n    is_there_blink_array = [is_there_blink_in_buffer1,is_there_blink_in_buffer2]\n    [axis1,axis2] = printTwoBlinks(channels, is_there_blink_array, buffer_size)",
        "detail": "Main",
        "documentation": {}
    },
    {
        "label": "printOneChannel",
        "kind": 2,
        "importPath": "PrintData",
        "description": "PrintData",
        "peekOfCode": "def printOneChannel(channel_data :list[float], color :str = \"blue\", name :str = \"\"):\n    # use time sample for x coordinates\n    x :list[int] = np.arange(len(channel_data))\n    # signal data in y axis\n    y :list[float] = channel_data\n    plt.figure(figsize=(10, 4))\n    plt.plot(x, y, color=color, linewidth=0.8, label=name)\n    plt.scatter(x, y, color=color, s=5)\n    plt.title(name)\n    plt.grid(True)",
        "detail": "PrintData",
        "documentation": {}
    },
    {
        "label": "printBufferedChannel",
        "kind": 2,
        "importPath": "PrintData",
        "description": "PrintData",
        "peekOfCode": "def printBufferedChannel(channel_data :list[float], buffer_sizes_for_channel :list[int], color :str = \"blue\"):\n    printOneChannel(channel_data, color) \n    # overlay the above signal with the buffers\n    for buffer_point in buffer_sizes_for_channel:\n        plt.axvline(x=buffer_point, color='green', linestyle='--', linewidth=1)\ndef printSignalWithThreshold(channel_data :list[float], threshold :float , buffer_sizes_for_channel :list[int],color :str = \"blue\"):\n    printBufferedChannel(channel_data,buffer_sizes_for_channel,color)\n    #overlay the signal with threshold line\n    plt.axhline(y=threshold, color=\"orange\", linestyle='--', linewidth=1)\ndef printBlinks(channel_data :list[float], buffer_size :int, is_there_blink_in_buffer :list[bool], color :str = \"blue\"):",
        "detail": "PrintData",
        "documentation": {}
    },
    {
        "label": "printSignalWithThreshold",
        "kind": 2,
        "importPath": "PrintData",
        "description": "PrintData",
        "peekOfCode": "def printSignalWithThreshold(channel_data :list[float], threshold :float , buffer_sizes_for_channel :list[int],color :str = \"blue\"):\n    printBufferedChannel(channel_data,buffer_sizes_for_channel,color)\n    #overlay the signal with threshold line\n    plt.axhline(y=threshold, color=\"orange\", linestyle='--', linewidth=1)\ndef printBlinks(channel_data :list[float], buffer_size :int, is_there_blink_in_buffer :list[bool], color :str = \"blue\"):\n    printOneChannel(channel_data, color)\n    current :int = 0\n    for blink in is_there_blink_in_buffer:\n        if(blink):\n            plt.axvline(x=current, color='red', linestyle='--', linewidth=1)",
        "detail": "PrintData",
        "documentation": {}
    },
    {
        "label": "printBlinks",
        "kind": 2,
        "importPath": "PrintData",
        "description": "PrintData",
        "peekOfCode": "def printBlinks(channel_data :list[float], buffer_size :int, is_there_blink_in_buffer :list[bool], color :str = \"blue\"):\n    printOneChannel(channel_data, color)\n    current :int = 0\n    for blink in is_there_blink_in_buffer:\n        if(blink):\n            plt.axvline(x=current, color='red', linestyle='--', linewidth=1)\n        current += buffer_size\ndef printTwoBlinks(channels :list[list[float]],is_there_blink_in_buffer_array :list[list[bool]], buffer_size :int,color1=\"blue\",color2=\"red\"):\n    [channel1  , channel2] = channels\n    [is_there_blink_in_buffer1, is_there_blink_in_buffer2] = is_there_blink_in_buffer_array",
        "detail": "PrintData",
        "documentation": {}
    },
    {
        "label": "printTwoBlinks",
        "kind": 2,
        "importPath": "PrintData",
        "description": "PrintData",
        "peekOfCode": "def printTwoBlinks(channels :list[list[float]],is_there_blink_in_buffer_array :list[list[bool]], buffer_size :int,color1=\"blue\",color2=\"red\"):\n    [channel1  , channel2] = channels\n    [is_there_blink_in_buffer1, is_there_blink_in_buffer2] = is_there_blink_in_buffer_array\n    axis1 = plt.subplot(2,1,1)\n    plt.title(\"Channels 1 & 2 :\")\n    plt.grid(True)\n    axis2 = plt.subplot(2,1,2)\n    plt.grid(True)\n    plt.legend()\n    x :list[int] = np.arange( np.max( len(channel1))) ",
        "detail": "PrintData",
        "documentation": {}
    },
    {
        "label": "extractEEGData",
        "kind": 2,
        "importPath": "Utils",
        "description": "Utils",
        "peekOfCode": "def extractEEGData(xdf_path :str):\n    streams , _ = pyxdf.load_xdf(xdf_path)\n    for stream in streams:\n        data = np.array(stream['time_series'])\n        return data\n    raise RuntimeError(\"Aucun flux EEG trouvé dans le fichier .xdf.\")\ndef getDataFromFile(path :str):\n    # raw_data contains the noise and the signal    \n    raw_data :list[list[float]] = extractEEGData(path)\n    # we separate the channel datas into distinct channels",
        "detail": "Utils",
        "documentation": {}
    },
    {
        "label": "getDataFromFile",
        "kind": 2,
        "importPath": "Utils",
        "description": "Utils",
        "peekOfCode": "def getDataFromFile(path :str):\n    # raw_data contains the noise and the signal    \n    raw_data :list[list[float]] = extractEEGData(path)\n    # we separate the channel datas into distinct channels\n    raw_channels :list[list[float]] = separateChannelData(raw_data)\n    channels :list[list[float]] = []\n    # we remove the noise part and keep only the signal\n    for raw_channel in raw_channels:\n        channels.append(raw_channel[:,1])\n    return channels",
        "detail": "Utils",
        "documentation": {}
    }
]